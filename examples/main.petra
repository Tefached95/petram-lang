{-
    This is a multiline comment.
    We can use this to use docblocks for describing function parameters and return types.
-}

func add_two_integers(a: Int, b: Int): Int
    return a + b
end

func divide_two_integers(dividend: Int, divisor: Int): Result<Int, String>
    if divisor == 0
        println(message: "Divisor must not be 0.")
        return Result::Error("Division by zero")
    end
    return Result::Ok(dividend / divisor)
end

{-
    Here's a moderately complex struct with invariants.
    An invariant is a mechanism that will not allow you to instantiate a struct if the check fails.
    NOTE: If you add one or more invariants to a struct, the return type of the constructor 
    changes from Self to Result<Self, String>, and you must use pattern matching for Ok(value) 
    or Error(error_message)
-}
struct Square
    funny_name: String
    side_length: Int
    
    invariant
        side_length > 0
    end
end

func Square::new(funny_name: String, side_length: Int): Result<Square, String>
    return Result::Ok(Square{
        funny_name: funny_name,
        side_length: side_length
    })
    -- Compiler automatically inserts invariant checks
end

func (s: Square) calculate_area(): Int
    return s.side_length * s.side_length
end

func (s: *Square) set_side_length(new_length: Int): Result<(), String>
    -- Invariants are checked automatically when mutating
    s.side_length = new_length
    return Result::Ok(())
end

-- This is a single line comment.
func main(args: List<String>): Int
    -- Simple variable declaration with type inference
    var a = 3

    -- Optional explicit type declaration
    var b: Int = 4
    
    -- Assignment via function call, with implicit and explicit types
    var res = add_two_integers(a: a, b: b)
    var res2: Int = add_two_integers_lambda(a, b)

    -- Instantiate a struct, which can potentially fail
    -- `match` is an expression, so it returns a value, like in Rust.
    var square = match Square::new(funny_name: "My Square", side_length: 5)
        case Result::Ok(s) ->
            println(message: "Square created successfully")
            Result::Ok(s)
        case Result::Error(error) ->
            println(message: "Error: {error}")
            Result::Error(error)
    end

    -- Discard return values with _
    var _ = match Square::new(funny_name: "Bad Square", side_length: -1)
        case Result::Ok(_) ->
            1  -- should never happen
        case Result::Error(error) ->
            println(message: "Error as expected: {error}")
            0
    end

    -- Print the result
    println(message: "{a} + {b} = {res}")
    return 0
end
